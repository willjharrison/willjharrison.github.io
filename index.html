<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sensory Intelligence Research Group</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root {
      --bg:#000; --fg:#b6fdb6; --glow:#19ff19;
      --rainColor: hsla(120, 80%, 20%, 1);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:hidden}

    #matrix{position:fixed;inset:0;z-index:0;display:block;width:100%;height:100%;
      background:radial-gradient(1200px 800px at 50% 50%, #001600 0%, #000 80%)}

    .wrap{position:fixed;top:0;left:0;right:0;display:flex;justify-content:center;align-items:flex-start;padding:16px 20px;z-index:1}

    h1{margin:0;text-align:center;letter-spacing:.06em;font-weight:700;font-size:clamp(22px,5.5vw,72px);
      color:#D4EB8E;text-shadow:0 0 .2rem #66ccff,0 0 .2rem #66ccff,0 0 .4rem #66ccff,0 0 .6rem var(--glow),0 0 1.2rem var(--glow),0 0 2.4rem var(--glow);
      filter:contrast(1.05) saturate(1.1) drop-shadow(0 0 .25rem #0a460a)}
    .crt{position:relative;isolation:isolate}
    .crt::before{content:"";position:absolute;inset:-2px;z-index:2;background:repeating-linear-gradient(to bottom,transparent 0 2px,rgba(255,255,255,.3) 2px 3px);mix-blend-mode:overlay;pointer-events:none;animation:scan 7s linear infinite}
    .crt::after{content:"";position:absolute;inset:-2px;z-index:1;background:radial-gradient(ellipse at center, rgba(0,255,0,.05), transparent 60%);pointer-events:none;filter:blur(2px)}
    @keyframes scan{0%{transform:translateY(-5%);opacity:.6}50%{opacity:.25}100%{transform:translateY(5%);opacity:.6}}
    footer{position:fixed;inset:auto 0 8px 0;text-align:center;font-size:12px;opacity:.55;z-index:1}
    @media (prefers-reduced-motion: reduce){.crt::before{animation:none}#matrix{display:none}}
  </style>
</head>
<body>
  <canvas id="matrix" aria-hidden="true"></canvas>

  <div class="wrap">
    <h1 id="title" class="crt">Sensory Intelligence Research Group</h1>
  </div>

  <footer>© <span id="y"></span> SIRG </footer>

  <script>
  (() => {
    const c = document.getElementById('matrix');
    const ctx = c.getContext('2d');

    // ==== Invisible menu words (mask + links) ====
    const MENU = [
      { text: 'ABOUT',         x: 80, y: 140, href: '#about' },
      { text: 'PUBLICATIONS',  x: 80, y: 200, href: '#pubs' },
    ];
    let maskCanvas, maskCtx, maskData = null;   // device-px alpha buffer
    let wordBoxes = [];                         // CSS-px hit boxes

    // ----- knobs -----
    const USE_DPR_1 = false;          // set true for max perf
    const RAIN = {
      rowsPerSec: 20,
      variability: 2,
      spacing: 0.85,
      trail: 0.02,
      pulseLambda: 0.15,
      pulseDecay: 0.4,
      minRowsPerSec: 10,
      minFactor: 0.10,
      maxGlyphStepsPerFrame: 2
    };
    const GLOW = { sigma: 8, maxAlpha: 0.06, recentMs: 200 }; // mouse micro-glow

    // ----- state -----
    let w, h, cols, dpr;
    let fontSize, glyphSpacing;
    let yRows, velRows, pulseA, rowFrac, lastRow;
    let lastSweep = 0, lastTs = 0;
    let rainColor = getComputedStyle(document.documentElement).getPropertyValue('--rainColor').trim();

    // tiny mouse glow sprite (DPR-aware)
    const mouse = { x: null, y: null, active: false, movedAt: 0 };
    let glowSprite = null, glowR = 0, glowCssSize = 0;
    window.addEventListener('pointermove', e => {
      mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true;
      mouse.movedAt = performance.now();
    }, {passive:true});
    window.addEventListener('pointerleave', () => mouse.active = false, {passive:true});

    function buildGlowSprite(){
      const dprLocal = USE_DPR_1 ? 1 : Math.max(1, Math.min(2, window.devicePixelRatio||1));
      glowR = Math.max(8, Math.round(GLOW.sigma * 3));
      glowCssSize = glowR * 2 + 1;
      const pxSize = Math.max(1, Math.round(glowCssSize * dprLocal));
      const off = document.createElement('canvas');
      off.width = pxSize; off.height = pxSize;
      const octx = off.getContext('2d');
      const img = octx.createImageData(pxSize, pxSize);
      const cx = pxSize/2, cy = pxSize/2;
      const sigmaPx = GLOW.sigma * dprLocal;
      const s2 = 2 * sigmaPx * sigmaPx;
      for (let y = 0; y < pxSize; y++) {
        for (let x = 0; x < pxSize; x++) {
          const dx = x - cx, dy = y - cy;
          const a = GLOW.maxAlpha * Math.exp(-(dx*dx + dy*dy) / s2);
          const i = (y * pxSize + x) * 4;
          // greenish cursor glow (tweak to taste)
          img.data[i]   = 0;
          img.data[i+1] = 225;
          img.data[i+2] = 0;
          img.data[i+3] = Math.round(a * 200);
        }
      }
      octx.putImageData(img, 0, 0);
      glowSprite = off;
    }

    const glyphs = 'アイウエオカキクケコサシスセソ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&*';

    function sampleVel(){
      const rawFactor = 1 + (Math.random()*2 - 1) * RAIN.variability;
      const clampedFactor = Math.max(RAIN.minFactor, rawFactor);
      return Math.max(RAIN.minRowsPerSec, RAIN.rowsPerSec * clampedFactor);
    }

    // ---- menu mask helpers ----
    function buildMenuMask(){
      // offscreen canvas matches device-px size of main canvas
      maskCanvas = document.createElement('canvas');
      maskCanvas.width  = c.width;
      maskCanvas.height = c.height;
      maskCtx = maskCanvas.getContext('2d');
      // draw with same DPR transform as main
      maskCtx.setTransform(dpr,0,0,dpr,0,0);
      maskCtx.clearRect(0,0,w,h);
      maskCtx.font = ctx.font;
      maskCtx.textBaseline = 'top';
      maskCtx.fillStyle = '#fff';

      wordBoxes = [];
      for (const m of MENU){
        const metrics = maskCtx.measureText(m.text);
        const boxW = Math.ceil(metrics.width);
        const boxH = Math.ceil(fontSize * 1.1);
        wordBoxes.push({ x:m.x, y:m.y, w:boxW, h:boxH, href:m.href, text:m.text });
        maskCtx.fillText(m.text, m.x, m.y);
      }
      maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;
    }

    function onMenuLetter(xCss, yCss){
      if (!maskData) return 0;
      const xi = Math.min(maskCanvas.width  - 1, Math.max(0, Math.round(xCss * dpr)));
      const yi = Math.min(maskCanvas.height - 1, Math.max(0, Math.round(yCss * dpr)));
      const idx = (yi * maskCanvas.width + xi) * 4;
      return maskData[idx + 3]; // alpha
    }

    // click → only when clicking real letter pixels, then route by word box
    c.addEventListener('click', (e) => {
      const x = e.clientX, y = e.clientY;
      if (onMenuLetter(x, y) === 0) return;
      for (const b of wordBoxes){
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h){
          window.location.hash = b.href;
          break;
        }
      }
    }, {passive:true});

    function resize(){
      dpr = USE_DPR_1 ? 1 : Math.max(1, Math.min(2, window.devicePixelRatio||1));
      w = window.innerWidth; h = window.innerHeight;
      c.width = Math.floor(w*dpr); c.height = Math.floor(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);

      fontSize = Math.max(12, Math.floor(w/70));
      glyphSpacing = Math.round(fontSize * RAIN.spacing);
      ctx.font = fontSize + 'px monospace';
      ctx.textBaseline = 'top';
      ctx.textAlign = 'left';

      cols   = Math.max(1, Math.ceil(w / glyphSpacing));
      yRows  = Array(cols).fill(0).map(()=> -Math.random()*50);
      velRows= Array(cols).fill(0).map(()=> sampleVel());
      pulseA = Array(cols).fill(0);
      rowFrac= Array(cols).fill(0);
      lastRow= Array(cols).fill(-1);

      rainColor = getComputedStyle(document.documentElement).getPropertyValue('--rainColor').trim();
      buildGlowSprite();
      buildMenuMask(); // << build the invisible words mask
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    function frame(ts){
      if(!lastTs) lastTs = ts;
      let dt = (ts - lastTs) / 1000;
      if (dt > 0.05) dt = 0.05; // cap dt spikes
      lastTs = ts;

      // light sweep to reduce burn-in
      const SWEEP_EVERY_MS = 350;
      const SWEEP_HEIGHT   = Math.max(18, Math.floor(glyphSpacing * 1.4));
      if (ts - lastSweep > SWEEP_EVERY_MS) {
        const y0 = (Math.random() * (h - SWEEP_HEIGHT)) | 0;
        ctx.clearRect(0, y0, w, SWEEP_HEIGHT);
        lastSweep = ts;
      }

      if (!document.hidden) {
        // trail fade
        ctx.fillStyle = `rgba(1,3,1,${RAIN.trail})`;
        ctx.fillRect(0,0,w,h);

        const maxRow = Math.ceil(h / glyphSpacing);

        for (let i=0;i<cols;i++) {
          rowFrac[i] += velRows[i] * dt;

          // Poisson red pulse
          const pPulse = 1 - Math.exp(-RAIN.pulseLambda * dt);
          if (pulseA[i] <= 0 && Math.random() < pPulse) pulseA[i] = 1;
          if (pulseA[i] > 0) pulseA[i] = Math.max(0, pulseA[i] - RAIN.pulseDecay * dt);

          // cap glyph steps per frame
          let steps = Math.floor(rowFrac[i]);
          if (steps > 0) {
            if (steps > RAIN.maxGlyphStepsPerFrame) {
              yRows[i] += (steps - RAIN.maxGlyphStepsPerFrame);
              steps = RAIN.maxGlyphStepsPerFrame;
            }
            rowFrac[i] -= Math.floor(rowFrac[i]);

            for (let s = 0; s < steps; s++) {
              yRows[i] += 1;
              const row = Math.floor(yRows[i]);

              if (row > maxRow) {
                yRows[i]   = - (10 + Math.random()*40);
                lastRow[i] = -1;
                rowFrac[i] = 0;
                pulseA[i]  = 0;
                velRows[i] = sampleVel();
                break;
              }

              if (row !== lastRow[i]) {
                const x = i * glyphSpacing;
                const y = row * glyphSpacing;

                // base glyph
                ctx.fillStyle = (pulseA[i] > 0)
                  ? `rgba(0,255,5,${pulseA[i].toFixed(3)})`
                  : rainColor;
                const ch = glyphs[(Math.random() * glyphs.length) | 0];
                ctx.fillText(ch, x, y);

                // MENU mask-driven glow: if glyph center hits a letter pixel, brighten it
                const a = onMenuLetter(x + glyphSpacing*0.4, y + fontSize*0.6);
                if (a > 0) {
                  const prev = ctx.globalCompositeOperation;
                  ctx.globalCompositeOperation = 'screen';
                  const boost = Math.min(0.45, 0.10 + (a/255) * 0.35);
                  ctx.fillStyle = `rgba(255,255,255,${boost.toFixed(3)})`;
                  ctx.fillText(ch, x, y);
                  ctx.globalCompositeOperation = prev;
                }

                lastRow[i] = row;
              }
            }
          }
        }
      }

      // tiny mouse-glow (only when pointer moved recently)
      if (mouse.active && glowSprite && mouse.x != null && (performance.now() - mouse.movedAt) < GLOW.recentMs) {
        const prev = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(glowSprite, mouse.x - glowR, mouse.y - glowR, glowCssSize, glowCssSize);
        ctx.globalCompositeOperation = prev;
      }

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Title micro-pulse
    (()=>{
      const el = document.getElementById('title');
      function pulseOnce(){
  const dur = 80 + Math.random()*220;
  const dim  = 0.1;           // how dark it gets (0–1)
  const bright = 1.0;         // baseline = no change

  // No scale changes → no bounce; only brightness flicker
  document.getElementById('title').animate([
    { filter:`brightness(${bright})` },
    { filter:`brightness(${dim})` },
    { filter:`brightness(${bright})` }
  ], { duration: dur, easing:'steps(2,end)' }); // snappy on/off
}
      (function schedule(){ setTimeout(()=>{ pulseOnce(); schedule(); }, 500 + Math.random()*3500); })();
    })();

    // Year
    document.getElementById('y').textContent = new Date().getFullYear();

    // expose
    window.CIR_RAIN = RAIN;
  })();
  </script>

  <!-- Optional anchor targets; style to taste -->
  <section id="about" style="position:relative; z-index:2; margin-top:60vh; padding:2rem; color:#b6fdb6;">
    <h2>About</h2>
    <p>Short blurb…</p>
  </section>
  <section id="pubs" style="position:relative; z-index:2; padding:2rem; color:#b6fdb6;">
    <h2>Publications</h2>
    <p>Coming soon…</p>
  </section>
</body>
</html>
