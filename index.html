<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Will Harrison Lab</title>
  <style>
    body { margin:0; background:#fff; }
    canvas { position:fixed; inset:0; z-index:-1; }
    main { max-width:800px; margin:2rem auto; font-family:sans-serif; color:#000; }
  </style>
</head>
<body>
  <canvas id="view"></canvas>

  <main>
    <h1>Will Harrison Lab</h1>
    <p>Welcome to our lab website. We study vision and cognition.</p>
  </main>

  <script>
    // ===== CONFIG (tweak) =====
    const CONFIG = {
      gaussianSD: 135,              // SD of coloured glow (px)
      sphereRadius: 135*2.5,        // radius of each aperture (px)
      edgeSD: 120,                  // SD of the *white mask* edge blur (px)
      numSpheres: 8,
      speedMeanSDsPerFrame: 0.06,   // motion speed mean (SDs/frame)
      speedStdSDsPerFrame:  0.03,   // motion speed SD
      speedMinSDsPerFrame:  0.012,  // motion min
      brightnessK: 0.9              // glow “punch” (higher=brighter overlaps)
    };

    // ===== Canvas + buffers =====
    const view = document.getElementById('view');
    const vctx = view.getContext('2d');
    let W, H, DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    const SCALE = 2; // render at lower res for speed (then upscale)

    // offscreen for glow
    let glowCanvas, gctx, gImg, gPx, GW, GH;
    // offscreen for white mask with holes (alpha)
    let maskCanvas, mctx, mImg, mPx, MW, MH;

    function mkCanvas(w,h){
      if (typeof OffscreenCanvas !== 'undefined') return new OffscreenCanvas(w,h);
      const c = document.createElement('canvas'); c.width=w; c.height=h; return c;
    }

    function resize(){
      W = view.width  = Math.floor(innerWidth  * DPR);
      H = view.height = Math.floor(innerHeight * DPR);
      view.style.width  = innerWidth + 'px';
      view.style.height = innerHeight + 'px';

      GW = MW = Math.max(Math.floor(W / SCALE), 1);
      GH = MH = Math.max(Math.floor(H / SCALE), 1);

      glowCanvas = mkCanvas(GW, GH); gctx = glowCanvas.getContext('2d');
      gImg = gctx.createImageData(GW, GH); gPx = gImg.data;

      maskCanvas = mkCanvas(MW, MH); mctx = maskCanvas.getContext('2d');
      mImg = mctx.createImageData(MW, MH); mPx = mImg.data;

      step.R = step.G = step.B = step.A = null; // realloc next frame

      // keep spheres inside
      for (const s of spheres){
        s.x = Math.min(Math.max(s.r, s.x), (W/DPR) - s.r);
        s.y = Math.min(Math.max(s.r, s.y), (H/DPR) - s.r);
      }
    }
    addEventListener('resize', resize);

    // ===== helpers =====
    const srgbToLin = c => (c <= 0.04045 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4));
    const linToSrgb = c => (c <= 0.0031308 ? 12.92*c : 1.055*Math.pow(c, 1/2.4) - 0.055);
    const clamp01 = x => x<0?0:x>1?1:x;
    function hsvToRgb(h,s,v){
      const i=Math.floor(h*6), f=h*6-i;
      const p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
      return [[v,t,p],[q,v,p],[p,v,t],[p,q,v],[t,p,v],[v,p,q]][i%6];
    }
    function randn(m=0,s=1){ let u=0,v=0; while(!u)u=Math.random(); while(!v)v=Math.random(); return m + s*Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

    // colours (even hues) → linear
    const colorsLIN = Array.from({length: CONFIG.numSpheres}, (_,i)=>{
      const [r,g,b] = hsvToRgb(i/CONFIG.numSpheres, 1, 1);
      return [srgbToLin(r), srgbToLin(g), srgbToLin(b)];
    });

    // spheres
    const spheres = [];
    for (let i=0;i<CONFIG.numSpheres;i++){
      let sSD = Math.abs(randn(CONFIG.speedMeanSDsPerFrame, CONFIG.speedStdSDsPerFrame));
      sSD = Math.max(sSD, CONFIG.speedMinSDsPerFrame);
      const speedPx = sSD * CONFIG.gaussianSD;
      const a = Math.random()*2*Math.PI;
      spheres.push({
        x: Math.random()*800 + 200,
        y: Math.random()*400 + 200,
        dx: speedPx*Math.cos(a),
        dy: speedPx*Math.sin(a),
        r: CONFIG.sphereRadius,
        color: colorsLIN[i%colorsLIN.length]
      });
    }

    resize();

    function step(){
      // move + bounce
      for (const s of spheres){
        s.x += s.dx; s.y += s.dy;
        if (s.x + s.r > W/DPR || s.x - s.r < 0) s.dx = -s.dx;
        if (s.y + s.r > H/DPR || s.y - s.r < 0) s.dy = -s.dy;
      }

      const N = GW*GH;
      // accumulators: glow RGB (linear), mask alpha (opaque=1, hole=0)
      if (!step.R || step.R.length!==N){
        step.R = new Float32Array(N);
        step.G = new Float32Array(N);
        step.B = new Float32Array(N);
        step.A = new Float32Array(N);
      } else {
        step.R.fill(0); step.G.fill(0); step.B.fill(0);
        // init mask to 1 (fully opaque white); we'll take min with each hole alpha
        step.A.fill(1);
      }
      const Rlin=step.R, Glin=step.G, Blin=step.B, Amsk=step.A;

      // precompute
      const inv2Glow = 1/(2*CONFIG.gaussianSD*CONFIG.gaussianSD);
      const edgeSD   = CONFIG.edgeSD;
      const inv2Edge = 1/(2*edgeSD*edgeSD);

      for (const s of spheres){
        const cx = (s.x*DPR)/SCALE, cy = (s.y*DPR)/SCALE;
        const rBuf = s.r / SCALE;

        // cover glow and mask edges
        const rad = Math.ceil(Math.max(rBuf*1.6, rBuf + (edgeSD/SCALE)*3));
        const x0 = Math.max(0, Math.floor(cx - rad));
        const y0 = Math.max(0, Math.floor(cy - rad));
        const x1 = Math.min(GW-1, Math.ceil(cx + rad));
        const y1 = Math.min(GH-1, Math.ceil(cy + rad));

        for (let y=y0; y<=y1; y++){
          const dy = (y+0.5 - cy)*SCALE; const dy2 = dy*dy;
          let idx = y*GW + x0;
          for (let x=x0; x<=x1; x++, idx++){
            const dx = (x+0.5 - cx)*SCALE;
            const d2 = dx*dx + dy2;
            const d  = Math.sqrt(d2);

            // --- bottom layer: coloured glow (additive in linear) ---
            const Ig = Math.exp(-d2 * inv2Glow);
            if (Ig >= 1e-4){
              const c = s.color;
              Rlin[idx] += c[0]*Ig;
              Glin[idx] += c[1]*Ig;
              Blin[idx] += c[2]*Ig;
            }

            // --- top layer: white alpha mask with Gaussian edge hole ---
            // inside hard aperture (d <= r): alpha=0 (fully transparent)
            // outside, alpha ramps to 1 with Gaussian of width edgeSD
            let a;
            if (d <= s.r) {
              a = 0;
            } else {
              const t = d - s.r;
              a = 1 - Math.exp(-(t*t)*inv2Edge); // 0 at edge, ->1 outward
            }
            // combine holes by taking the MIN alpha across spheres
            if (a < Amsk[idx]) Amsk[idx] = a;
          }
        }
      }

      // --- build glow image (opaque; we draw mask on top) ---
      const k = CONFIG.brightnessK;
      let p = 0;
      for (let i=0;i<N;i++){
        const rl = 1 - Math.exp(-k*Rlin[i]);
        const gl = 1 - Math.exp(-k*Glin[i]);
        const bl = 1 - Math.exp(-k*Blin[i]);
        gPx[p++] = Math.round(clamp01(linToSrgb(rl))*255);
        gPx[p++] = Math.round(clamp01(linToSrgb(gl))*255);
        gPx[p++] = Math.round(clamp01(linToSrgb(bl))*255);
        gPx[p++] = 255;
      }
      gctx.putImageData(gImg, 0, 0);

      // --- build white mask image with per-pixel alpha ---
      p = 0;
      for (let i=0;i<N;i++){
        mPx[p++] = 255;   // R
        mPx[p++] = 255;   // G
        mPx[p++] = 255;   // B
        mPx[p++] = Math.round(clamp01(Amsk[i])*255); // A
      }
      mctx.putImageData(mImg, 0, 0);

      // --- composite to view: draw glow, then draw white mask (with holes) ---
      vctx.clearRect(0,0,W,H);
      vctx.imageSmoothingEnabled = true;
      vctx.drawImage(glowCanvas, 0, 0, W, H);
      vctx.drawImage(maskCanvas, 0, 0, W, H);

      requestAnimationFrame(step);
    }
    step();
  </script>
</body>
</html>
