<!doctype html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sensory Intelligence Research Group</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root {
      --bg:#000; --fg:#b6fdb6; --glow:#19ff19;
      --rainColor: hsla(120, 80%, 20%, 1);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:hidden}

    /* Background rain */
    #matrix{position:fixed;inset:0;z-index:0;display:block;width:100%;height:100%;
      background:radial-gradient(1200px 800px at 50% 50%, #001600 0%, #000 80%)}

    /* Foreground “glass text” overlay canvas */
    #glass{position:fixed;inset:0;z-index:1;display:block;width:100%;height:100%;pointer-events:auto}

    .wrap{position:fixed;top:0;left:0;right:0;display:flex;justify-content:center;align-items:flex-start;padding:16px 20px;z-index:2}

    h1{font-family: 'VT323', monospace; margin:0;text-align:center;letter-spacing:.06em;font-weight:700;font-size:clamp(22px,5.5vw,72px);
      color:#D4EB8E;text-shadow:0 0 .2rem #66ccff,0 0 .2rem #66ccff,0 0 .4rem #66ccff,0 0 .6rem var(--glow),0 0 1.2rem var(--glow),0 0 2.4rem var(--glow);
      filter:contrast(1.05) saturate(1.1) drop-shadow(0 0 .25rem #0a460a)}
    .crt{position:relative;isolation:isolate}
    .crt::before{content:"";position:absolute;inset:-2px;z-index:2;background:repeating-linear-gradient(to bottom,transparent 0 2px,rgba(255,255,255,.3) 2px 3px);mix-blend-mode:overlay;pointer-events:none;animation:scan 7s linear infinite}
    .crt::after{content:"";position:absolute;inset:-2px;z-index:1;background:radial-gradient(ellipse at center, rgba(0,255,0,.05), transparent 60%);pointer-events:none;filter:blur(2px)}
    @keyframes scan{0%{transform:translateY(-5%);opacity:.6}50%{opacity:.25}100%{transform:translateY(5%);opacity:.6}}
    footer{position:fixed;inset:auto 0 8px 0;text-align:center;font-size:12px;opacity:.55;z-index:2}

    @media (prefers-reduced-motion: reduce){.crt::before{animation:none}#matrix{display:none}}
  </style>
</head>
<body>
  <canvas id="matrix" aria-hidden="true"></canvas>
  <canvas id="glass"  aria-hidden="false"></canvas>

  <div class="wrap">
    <h1 id="title" class="crt">Sensory Intelligence Research Group</h1>
  </div>

  <footer>© <span id="y"></span> SIRG </footer>

  <script>
  (() => {
    const c  = document.getElementById('matrix');
    const gC = document.getElementById('glass');
    const ctx  = c.getContext('2d');
    const gtx  = gC.getContext('2d');

    // ==== Menu spec (CSS px positions; bigger font via scale) ====
    const MENU = [
      { text: 'ABOUT',        x: 80,  y: 160, href: '#about' },
      { text: 'PUBLICATIONS', x: 80,  y: 240, href: '#pubs'  },
    ];

    // ----- knobs -----
    const USE_DPR_1 = false;            // set true for max perf
    const MENU_FONT_SCALE = 2.6;        // menu text size relative to rain font
    const GLASS = {
      blurPx: 1.6,                      // blur radius inside letters
      tint: 'rgba(60,220,120,0.22)',    // “green glass” tint
      stroke: 'rgba(140,255,180,0.6)',  // edge highlight
      strokeWidthFactor: 0.08           // of menu font size
    };
    const RAIN = {
      rowsPerSec: 20, variability: 2, spacing: 0.85, trail: 0.02,
      pulseLambda: 0.15, pulseDecay: 0.4,
      minRowsPerSec: 10, minFactor: 0.10,
      maxGlyphStepsPerFrame: 2
    };
    const GLOW = { sigma: 8, maxAlpha: 0.06, recentMs: 200 }; // mouse micro-glow

    // ----- state -----
    let w, h, cols, dpr;
    let fontSize, glyphSpacing;
    let yRows, velRows, pulseA, rowFrac, lastRow;
    let lastSweep = 0, lastTs = 0;
    let rainColor = getComputedStyle(document.documentElement).getPropertyValue('--rainColor').trim();

    // clickable boxes for menu (in CSS px)
    let wordBoxes = [];

    // tiny mouse glow sprite (DPR-aware)
    const mouse = { x: null, y: null, active: false, movedAt: 0 };
    let glowSprite = null, glowR = 0, glowCssSize = 0;
    window.addEventListener('pointermove', e => {
      mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true;
      mouse.movedAt = performance.now();
    }, {passive:true});
    window.addEventListener('pointerleave', () => mouse.active = false, {passive:true});

    function buildGlowSprite(){
      const dprLocal = USE_DPR_1 ? 1 : Math.max(1, Math.min(2, window.devicePixelRatio||1));
      glowR = Math.max(8, Math.round(GLOW.sigma * 3));
      glowCssSize = glowR * 2 + 1;
      const pxSize = Math.max(1, Math.round(glowCssSize * dprLocal));
      const off = document.createElement('canvas'); off.width = pxSize; off.height = pxSize;
      const octx = off.getContext('2d');
      const img = octx.createImageData(pxSize, pxSize);
      const cx = pxSize/2, cy = pxSize/2, sigmaPx = GLOW.sigma * dprLocal, s2 = 2 * sigmaPx * sigmaPx;
      for (let y = 0; y < pxSize; y++) for (let x = 0; x < pxSize; x++) {
        const dx = x - cx, dy = y - cy;
        const a = GLOW.maxAlpha * Math.exp(-(dx*dx + dy*dy) / s2);
        const i = (y * pxSize + x) * 4;
        img.data[i]   = 0; img.data[i+1] = 225; img.data[i+2] = 0; img.data[i+3] = Math.round(a * 200);
      }
      octx.putImageData(img, 0, 0);
      glowSprite = off;
    }

    const glyphs = 'アイウエオカキクケコサシスセソ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&*';

    function sampleVel(){
      const raw = 1 + (Math.random()*2 - 1) * RAIN.variability;
      const clamped = Math.max(RAIN.minFactor, raw);
      return Math.max(RAIN.minRowsPerSec, RAIN.rowsPerSec * clamped);
    }

    function resize(){
      dpr = USE_DPR_1 ? 1 : Math.max(1, Math.min(2, window.devicePixelRatio||1));
      w = window.innerWidth; h = window.innerHeight;
      c.width = Math.floor(w*dpr); c.height = Math.floor(h*dpr);
      gC.width = c.width; gC.height = c.height;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      gtx.setTransform(dpr,0,0,dpr,0,0);

      fontSize = Math.max(12, Math.floor(w/70));
      glyphSpacing = Math.round(fontSize * RAIN.spacing);

      // Rain font
      ctx.font = fontSize + 'px monospace';
      ctx.textBaseline = 'top'; ctx.textAlign = 'left';

      // Menu font (bigger)
      const menuPx = Math.round(fontSize * MENU_FONT_SCALE);
      gtx.font = menuPx + 'px monospace';
      gtx.textBaseline = 'top'; gtx.textAlign = 'left';

      cols   = Math.max(1, Math.ceil(w / glyphSpacing));
      yRows  = Array(cols).fill(0).map(()=> -Math.random()*50);
      velRows= Array(cols).fill(0).map(()=> sampleVel());
      pulseA = Array(cols).fill(0);
      rowFrac= Array(cols).fill(0);
      lastRow= Array(cols).fill(-1);

      rainColor = getComputedStyle(document.documentElement).getPropertyValue('--rainColor').trim();
      buildGlowSprite();

      // update clickable word boxes (CSS px, based on menu font)
      wordBoxes = MENU.map(m => {
        const mw = gtx.measureText(m.text).width;
        return { x:m.x, y:m.y, w:Math.ceil(mw), h:Math.ceil(menuPx*1.1), href:m.href, text:m.text, menuPx };
      });
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // Draw glass effect for a single word (per-word bounding box; DPR-correct)
    function drawGlassWord(m){
      const menuPx = gtx.measureText('M').fontBoundingBoxAscent ? (gtx.measureText('M').fontBoundingBoxAscent + gtx.measureText('M').fontBoundingBoxDescent) : parseInt(gtx.font,10);
      const metrics = gtx.measureText(m.text);
      const wBox = Math.ceil(metrics.width);
      const hBox = Math.ceil(wordBoxes[0]?.menuPx ? wordBoxes[0].menuPx*1.1 : parseInt(gtx.font,10)*1.1);

      // Clear just this word's region on overlay
      gtx.clearRect(m.x - 4, m.y - 4, wBox + 8, hBox + 8);

      // 1) Paint text (white) to become the destination mask
      gtx.globalCompositeOperation = 'source-over';
      gtx.fillStyle = '#fff';
      gtx.fillText(m.text, m.x, m.y);

      // 2) Clip background into letters using 'source-in' (blurred & saturated)
      gtx.globalCompositeOperation = 'source-in';
      gtx.filter = `blur(${GLASS.blurPx}px) saturate(1.2)`;
      // Copy only the needed background sub-rect (device px for source)
      const sx = Math.round(m.x * dpr), sy = Math.round(m.y * dpr);
      const sw = Math.round(wBox * dpr), sh = Math.round(hBox * dpr);
      gtx.drawImage(c, sx, sy, sw, sh, m.x, m.y, wBox, hBox);
      gtx.filter = 'none';

      // 3) Tint the clipped background to green glass
      gtx.globalCompositeOperation = 'source-atop';
      gtx.fillStyle = GLASS.tint;
      gtx.fillRect(m.x, m.y, wBox, hBox);

      // 4) Edge highlight
      gtx.globalCompositeOperation = 'source-over';
      gtx.lineWidth = Math.max(1, (parseInt(gtx.font,10) * GLASS.strokeWidthFactor));
      gtx.strokeStyle = GLASS.stroke;
      gtx.strokeText(m.text, m.x, m.y);
    }

    function drawGlassMenu(){
      // Redraw each word’s filtered region
      for (const m of MENU) drawGlassWord(m);
    }

    function frame(ts){
      if(!lastTs) lastTs = ts;
      let dt = (ts - lastTs) / 1000;
      if (dt > 0.05) dt = 0.05; // cap dt spikes
      lastTs = ts;

      // light sweep to reduce burn-in
      const SWEEP_EVERY_MS = 350;
      const SWEEP_HEIGHT   = Math.max(18, Math.floor(glyphSpacing * 1.4));
      if (ts - lastSweep > SWEEP_EVERY_MS) {
        const y0 = (Math.random() * (h - SWEEP_HEIGHT)) | 0;
        ctx.clearRect(0, y0, w, SWEEP_HEIGHT);
        lastSweep = ts;
      }

      if (!document.hidden) {
        // trail fade
        ctx.fillStyle = `rgba(1,3,1,${RAIN.trail})`;
        ctx.fillRect(0,0,w,h);

        const maxRow = Math.ceil(h / glyphSpacing);

        for (let i=0;i<cols;i++) {
          rowFrac[i] += velRows[i] * dt;

          const pPulse = 1 - Math.exp(-RAIN.pulseLambda * dt);
          if (pulseA[i] <= 0 && Math.random() < pPulse) pulseA[i] = 1;
          if (pulseA[i] > 0) pulseA[i] = Math.max(0, pulseA[i] - RAIN.pulseDecay * dt);

          let steps = Math.floor(rowFrac[i]);
          if (steps > 0) {
            if (steps > RAIN.maxGlyphStepsPerFrame) {
              yRows[i] += (steps - RAIN.maxGlyphStepsPerFrame);
              steps = RAIN.maxGlyphStepsPerFrame;
            }
            rowFrac[i] -= Math.floor(rowFrac[i]);

            for (let s = 0; s < steps; s++) {
              yRows[i] += 1;
              const row = Math.floor(yRows[i]);

              if (row > maxRow) {
                yRows[i]   = - (10 + Math.random()*40);
                lastRow[i] = -1;
                rowFrac[i] = 0;
                pulseA[i]  = 0;
                velRows[i] = sampleVel();
                break;
              }

              if (row !== lastRow[i]) {
                const x = i * glyphSpacing;
                const y = row * glyphSpacing;
                ctx.fillStyle = (pulseA[i] > 0)
                  ? `rgba(0,255,5,${pulseA[i].toFixed(3)})`
                  : rainColor;
                const ch = glyphs[(Math.random() * glyphs.length) | 0];
                ctx.fillText(ch, x, y);
                lastRow[i] = row;
              }
            }
          }
        }
      }

      // tiny mouse-glow (only when pointer moved recently)
      if (mouse.active && glowSprite && mouse.x != null && (performance.now() - mouse.movedAt) < GLOW.recentMs) {
        const prev = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(glowSprite, mouse.x - glowR, mouse.y - glowR, glowCssSize, glowCssSize);
        ctx.globalCompositeOperation = prev;
      }

      // draw the glass-text overlay last so it always sits on top
      drawGlassMenu();

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // Title brightness flicker (no scale bounce)
    (()=>{
      function pulseOnce(){
        const dur = 80 + Math.random()*220;
        const dim  = 0.1;
        const bright = 1.0;
        document.getElementById('title').animate([
          { filter:`brightness(${bright})` },
          { filter:`brightness(${dim})` },
          { filter:`brightness(${bright})` }
        ], { duration: dur, easing:'steps(2,end)' });
      }
      (function schedule(){ setTimeout(()=>{ pulseOnce(); schedule(); }, 500 + Math.random()*3500); })();
    })();

    // Click routing for the glass text (bounding boxes)
    gC.addEventListener('click', (e) => {
      const x = e.clientX, y = e.clientY;
      for (const b of wordBoxes){
        if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h){
          window.location.hash = b.href; break;
        }
      }
    }, {passive:true});

    // Year
    document.getElementById('y').textContent = new Date().getFullYear();

    // expose
    window.CIR_RAIN = RAIN;
  })();
  </script>
</body>
</html>
