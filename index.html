<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Will Harrison Lab</title>
  <style>
    body { margin: 0; background:#fff; }
    canvas { position: fixed; inset: 0; z-index: -1; }
    main { max-width: 800px; margin: 2rem auto; font-family: sans-serif; color:#000; }

    /* Retro 4-bit control panel */
    .panel {
      position: fixed; top: 12px; right: 12px; z-index: 10;
      background: #111; color: #0f0; border: 2px solid #333; padding: 10px;
      font-family: "Courier New", Courier, monospace; image-rendering: pixelated;
      box-shadow: 0 0 0 2px #000, 0 0 12px rgba(0,0,0,.4);
    }
    .panel h3 {
      margin: 0 0 8px 0; font-weight: 700; font-size: 12px; letter-spacing: 1px; color:#9f9;
      text-transform: uppercase;
    }
    .row { display: grid; grid-template-columns: 80px 160px 26px; gap: 6px; align-items: center; margin: 6px 0; }
    .lbl { font-size: 11px; color:#9f9; }
    .val {
      width: 26px; text-align:center; font-weight:700; font-size: 12px; color:#111; background:#9f9; border:1px solid #5c5;
    }
    input[type=range]{
      -webkit-appearance:none; appearance:none; width:100%; height:10px; background:#222; border:1px solid #333;
    }
    input[type=range]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none; width:14px; height:14px; background:#9f9; border:2px solid #060;
      box-shadow: 0 0 0 1px #000; cursor:pointer;
    }
    input[type=range]::-moz-range-thumb{
      width:14px; height:14px; background:#9f9; border:2px solid #060; cursor:pointer;
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>

  <!-- Retro control panel -->
  <div class="panel" id="panel">
    <h3>Controls</h3>
    <div class="row">
      <div class="lbl">Speed</div>
      <input id="kn-speed" type="range" min="1" max="10" value="6">
      <input id="val-speed" class="val" type="text" value="6" readonly>
    </div>
    <div class="row">
      <div class="lbl">Glow</div>
      <input id="kn-glow" type="range" min="1" max="10" value="6">
      <input id="val-glow" class="val" type="text" value="6" readonly>
    </div>
    <div class="row">
      <div class="lbl">Hole Size</div>
      <input id="kn-holecore" type="range" min="1" max="10" value="6">
      <input id="val-holecore" class="val" type="text" value="6" readonly>
    </div>
    <div class="row">
      <div class="lbl">Hole Soft</div>
      <input id="kn-holesoft" type="range" min="1" max="10" value="6">
      <input id="val-holesoft" class="val" type="text" value="6" readonly>
    </div>
    <div class="row">
      <div class="lbl">Edge SD</div>
      <input id="kn-edgesd" type="range" min="1" max="10" value="6">
      <input id="val-edgesd" class="val" type="text" value="6" readonly>
    </div>
  </div>

  <main id="content">
    <h1>Will Harrison Lab</h1>
    <p>Welcome to our lab website. We study vision and cognition.</p>
  </main>

  <script>
    // ======== CONFIG (defaults) ========
    const CONFIG = {
      gaussianSD: 135,                 // base SD (px) for coloured glow
      sphereRadius: null,              // null => auto = gaussianSD * 2.5

      // motion (defaults ≈ your current)
      speedMeanSDsPerFrame: 0.06,
      speedStdSDsPerFrame:  0.03,
      speedMinSDsPerFrame:  0.012,

      numSpheres: 8,
      backgroundColor: 'white',
      textColor: 'black',

      // glow tonemapping
      brightnessK: 0.9,

      // black-hole (core + edge)
      holeEdgeSD: null,                // null => gaussianSD * 0.9
      holeCoreMarginSDs: 2.0,          // core radius = R - holeCoreMarginSDs*holeEdgeSD
      holeMax: 1.0                     // 1.0 = pure black centre
    };
    if (CONFIG.sphereRadius == null) CONFIG.sphereRadius = CONFIG.gaussianSD * 2.5;
    if (CONFIG.holeEdgeSD == null)   CONFIG.holeEdgeSD   = CONFIG.gaussianSD * 0.9;

    // Page colours
    document.body.style.background = CONFIG.backgroundColor;
    document.getElementById('content').style.color = CONFIG.textColor;

    // ======== Canvas setup ========
    const cvs = document.getElementById('bg');
    const ctx = cvs.getContext('2d');
    const SCALE = 2; // perf
    let W, H, DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    let BUF_W, BUF_H, buf, bctx, imgData, px;

    // sRGB <-> linear helpers
    const srgbToLin = c => (c <= 0.04045 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4));
    const linToSrgb = c => (c <= 0.0031308 ? 12.92*c : 1.055*Math.pow(c, 1/2.4) - 0.055);
    const clamp01 = x => x < 0 ? 0 : (x > 1 ? 1 : x);

    // HSV -> sRGB (0..1)
    function hsvToRgb(h, s, v){
      const i = Math.floor(h*6), f = h*6 - i;
      const p = v*(1-s), q = v*(1-f*s), t = v*(1-(1-f)*s);
      const m = [[v,t,p],[q,v,p],[p,v,t],[p,q,v],[t,p,v],[v,p,q]][i%6];
      return m;
    }

    // Normal sampler
    function randn(m=0, s=1) {
      let u=0, v=0; while(!u) u=Math.random(); while(!v) v=Math.random();
      return m + s * Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
    }

    // Colours (even hues) → linear
    function makeColors(n){
      return Array.from({length:n}, (_,i) => {
        const h = i / n;
        const [r,g,b] = hsvToRgb(h, 1, 1);
        return [srgbToLin(r), srgbToLin(g), srgbToLin(b)];
      });
    }
    let colorsLIN = makeColors(CONFIG.numSpheres);

    // Spheres
    let spheres = [];
    function reinitSpheres(keepPositions=false){
      const newSpheres = [];
      for (let i=0; i<CONFIG.numSpheres; i++) {
        let sSD = Math.abs(randn(CONFIG.speedMeanSDsPerFrame, CONFIG.speedStdSDsPerFrame));
        sSD = Math.max(sSD, CONFIG.speedMinSDsPerFrame);
        const speedPx = sSD * CONFIG.gaussianSD;
        const ang = Math.random()*2*Math.PI;
        const old = spheres[i];
        newSpheres.push({
          x: keepPositions && old ? old.x : Math.random()*800 + 200,
          y: keepPositions && old ? old.y : Math.random()*400 + 200,
          dx: speedPx * Math.cos(ang),
          dy: speedPx * Math.sin(ang),
          r: CONFIG.sphereRadius,
          color: colorsLIN[i % colorsLIN.length]
        });
      }
      spheres = newSpheres;
    }

    function resize() {
      W = cvs.width  = Math.floor(window.innerWidth  * DPR);
      H = cvs.height = Math.floor(window.innerHeight * DPR);
      cvs.style.width  = window.innerWidth + 'px';
      cvs.style.height = window.innerHeight + 'px';

      BUF_W = Math.max(Math.floor(W / SCALE), 1);
      BUF_H = Math.max(Math.floor(H / SCALE), 1);

      if (typeof OffscreenCanvas !== 'undefined') {
        buf = new OffscreenCanvas(BUF_W, BUF_H);
      } else {
        buf = document.createElement('canvas');
        buf.width = BUF_W; buf.height = BUF_H;
      }
      bctx = buf.getContext('2d');
      imgData = bctx.createImageData(BUF_W, BUF_H);
      px = imgData.data;

      step.R = step.G = step.B = step.M = null;

      for (const s of spheres) {
        s.x = Math.min(Math.max(s.r, s.x), (W/DPR) - s.r);
        s.y = Math.min(Math.max(s.r, s.y), (H/DPR) - s.r);
      }
    }
    window.addEventListener('resize', resize);

    // Init
    reinitSpheres(false);
    resize();

    function step() {
      // move & bounce
      for (const s of spheres) {
        s.x += s.dx; s.y += s.dy;
        if (s.x + s.r > W/DPR || s.x - s.r < 0) s.dx = -s.dx;
        if (s.y + s.r > H/DPR || s.y - s.r < 0) s.dy = -s.dy;
      }

      // accumulators
      const N = BUF_W * BUF_H;
      if (!step.R || step.R.length !== N) {
        step.R = new Float32Array(N); // glow R
        step.G = new Float32Array(N); // glow G
        step.B = new Float32Array(N); // glow B
        step.M = new Float32Array(N); // black-hole mask
      } else { step.R.fill(0); step.G.fill(0); step.B.fill(0); step.M.fill(0); }
      const Rlin = step.R, Glin = step.G, Blin = step.B, Mask = step.M;

      // precompute
      const glowSigma2 = CONFIG.gaussianSD * CONFIG.gaussianSD;
      const inv2Glow   = 1 / (2*glowSigma2);
      const edgeSD     = CONFIG.holeEdgeSD;
      const inv2Edge   = 1 / (2*edgeSD*edgeSD);

      for (const s of spheres) {
        const rBuf   = s.r / SCALE;
        const cxBuf  = (s.x * DPR) / SCALE;
        const cyBuf  = (s.y * DPR) / SCALE;

        const coreR   = Math.max(0, s.r - CONFIG.holeCoreMarginSDs * edgeSD);
        const coreR_b = coreR / SCALE;

        const rad = Math.ceil(Math.max(rBuf*1.6, coreR_b + (edgeSD/SCALE)*3));
        const x0 = Math.max(0, Math.floor(cxBuf - rad));
        const y0 = Math.max(0, Math.floor(cyBuf - rad));
        const x1 = Math.min(BUF_W-1, Math.ceil(cxBuf + rad));
        const y1 = Math.min(BUF_H-1, Math.ceil(cyBuf + rad));

        for (let y=y0; y<=y1; y++) {
          const dy = (y + 0.5 - cyBuf) * SCALE; const dy2 = dy*dy;
          let idx = y*BUF_W + x0;
          for (let x=x0; x<=x1; x++, idx++) {
            const dx = (x + 0.5 - cxBuf) * SCALE; const d2 = dx*dx + dy2; const d = Math.sqrt(d2);

            // glow
            const Ig = Math.exp(-d2 * inv2Glow);
            if (Ig >= 1e-4) {
              const c = s.color;
              Rlin[idx] += c[0] * Ig;
              Glin[idx] += c[1] * Ig;
              Blin[idx] += c[2] * Ig;
            }

            // black-hole mask
            let m;
            if (d <= coreR) m = 1; else {
              const t = d - coreR;
              m = Math.exp(- (t*t) * inv2Edge);
            }
            if (d > s.r + 3*edgeSD) m = 0;
            if (m > Mask[idx]) Mask[idx] = m;
          }
        }
      }

      // Compose over WHITE in linear light
      const kGlow  = CONFIG.brightnessK;
      const holeMx = CONFIG.holeMax;
      let p = 0;
      for (let i=0; i<N; i++) {
        const base = 1 - holeMx * Mask[i];
        const r = Math.min(1, Math.max(0, base + (1 - Math.exp(-kGlow * Rlin[i]))));
        const g = Math.min(1, Math.max(0, base + (1 - Math.exp(-kGlow * Glin[i]))));
        const b = Math.min(1, Math.max(0, base + (1 - Math.exp(-kGlow * Blin[i]))));

        px[p++] = Math.round(clamp01(linToSrgb(r)) * 255);
        px[p++] = Math.round(clamp01(linToSrgb(g)) * 255);
        px[p++] = Math.round(clamp01(linToSrgb(b)) * 255);
        px[p++] = 255;
      }

      bctx.putImageData(imgData, 0, 0);
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,W,H);
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(buf, 0, 0, W, H);

      requestAnimationFrame(step);
    }
    step();

    // ======== KNOBS (1–10) → parameter mapping ========
    // Speed knob (1..10) → mean in [0.012..0.12], std≈mean/2, min≈mean/5
    const knSpeed = document.getElementById('kn-speed'), valSpeed = document.getElementById('val-speed');
    const knGlow  = document.getElementById('kn-glow'),  valGlow  = document.getElementById('val-glow');
    const knCore  = document.getElementById('kn-holecore'), valCore = document.getElementById('val-holecore');
    const knSoft  = document.getElementById('kn-holesoft'), valSoft = document.getElementById('val-holesoft');
    const knEdge  = document.getElementById('kn-edgesd'),   valEdge = document.getElementById('val-edgesd');

    function mapSpeed(level){
      const mean = 0.012 + (level-1) * (0.108/9);  // 0.012..0.12
      CONFIG.speedMeanSDsPerFrame = mean;
      CONFIG.speedStdSDsPerFrame  = mean * 0.5;
      CONFIG.speedMinSDsPerFrame  = mean * 0.2;
      reinitSpheres(true); // keep positions, update velocities
    }
    function mapGlow(level){
      CONFIG.brightnessK = 0.5 + (level-1) * (1.5-0.5)/9;   // 0.5..1.5
    }
    function mapHoleSize(level){
      CONFIG.holeCoreMarginSDs = 0.5 + (level-1) * (3.0-0.5)/9; // 0.5..3.0
    }
    function mapHoleSoft(level){
      // soften by scaling holeEdgeSD around gaussianSD
      const factor = 0.5 + (level-1) * (1.5-0.5)/9; // 0.5..1.5
      CONFIG.holeEdgeSD = CONFIG.gaussianSD * factor;
    }
    function mapEdgeSD(level){
      // change coloured glow SD around base; also refresh radius so proportions hold
      const base = 90; // a comfortable baseline
      CONFIG.gaussianSD = 60 + (level-1) * (200-60)/9; // 60..200
      CONFIG.sphereRadius = CONFIG.gaussianSD * 2.5;
      // keep hole softness proportional unless user changed it via Hole Soft just now
      // (we don’t override it here; user can tweak with Hole Soft)
      // re-speed since speeds are in SD units:
      reinitSpheres(true);
    }

    function bind(kn, val, fn){
      const upd = () => { val.value = kn.value; fn(+kn.value); };
      kn.addEventListener('input', upd); kn.addEventListener('change', upd); upd();
    }
    bind(knSpeed, valSpeed, mapSpeed);
    bind(knGlow,  valGlow,  mapGlow);
    bind(knCore,  valCore,  mapHoleSize);
    bind(knSoft,  valSoft,  mapHoleSoft);
    bind(knEdge,  valEdge,  mapEdgeSD);
  </script>
</body>
</html>
