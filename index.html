<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Computational Intelligence Research</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root {
      --bg:#000; --fg:#b6fdb6; --glow:#19ff19;
      /* Rain color: lower saturation = more desaturated */
      --rainColor: hsla(120, 60%, 60%, 1);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:hidden}

    /* Fullscreen matrix canvas */
    #matrix{position:fixed;inset:0;z-index:0;display:block;width:100%;height:100%;background:radial-gradient(1200px 800px at 50% 50%, #001600 0%, #000 80%)}

    /* Title bar pinned to top */
    .wrap{position:fixed;top:0;left:0;right:0;display:flex;justify-content:center;align-items:flex-start;padding:16px 20px;z-index:1}

    h1{margin:0;text-align:center;letter-spacing:.06em;font-weight:700;font-size:clamp(22px,5.5vw,72px);text-shadow:0 0 .6rem var(--glow),0 0 1.2rem var(--glow),0 0 2.4rem var(--glow);filter:contrast(1.05) saturate(1.1) drop-shadow(0 0 .25rem #0a460a)}

    /* CRT scanlines */
    .crt{position:relative;isolation:isolate}
    .crt::before{content:"";position:absolute;inset:-2px;z-index:2;background:repeating-linear-gradient(to bottom,transparent 0 2px,rgba(255,255,255,.03) 2px 3px);mix-blend-mode:overlay;pointer-events:none;animation:scan 7s linear infinite}
    .crt::after{content:"";position:absolute;inset:-2px;z-index:1;background:radial-gradient(ellipse at center, rgba(0,255,0,.12), transparent 60%);pointer-events:none;filter:blur(2px)}
    @keyframes scan{0%{transform:translateY(-5%);opacity:.6}50%{opacity:.25}100%{transform:translateY(5%);opacity:.6}}

    footer{position:fixed;inset:auto 0 8px 0;text-align:center;font-size:12px;opacity:.55;z-index:1}

    @media (prefers-reduced-motion: reduce){.crt::before{animation:none}#matrix{display:none}}
  </style>
</head>
<body>
  <canvas id="matrix" aria-hidden="true"></canvas>

  <div class="wrap">
    <h1 id="title" class="crt">Biological Intelligence Research</h1>
  </div>

  <footer>© <span id="y"></span> CIR</footer>

  <script>
    // ===== Matrix rain (equal SPATIAL rate + red pulse + row smoothing) =====
    (() => {
      const c = document.getElementById('matrix');
      const ctx = c.getContext('2d');
      let w, h, cols, dpr;
      let fontSize, glyphSpacing;
      // positions (ROWS), velocities (ROWS/sec), red pulse alpha, fractional rows, last drawn row
      let yRows, velRows, pulseA, rowFrac, lastRow;

      /* Controls
         - rowsPerSec: target spatial rate in ROWS/second (≈ equal across columns)
         - variability: ± jitter across columns (0 = identical)
         - spacing: vertical spacing relative to font size (1.0 = tight)
         - trail: background fade per frame (lower = longer trails)
         - pulseLambda: expected red-pulse events per second per column
         - pulseDecay: red alpha decay per second */
      const RAIN = {
        rowsPerSec: 4,
        variability: 0.90,
        spacing: 1.00,
        trail: 0.02,
        pulseLambda: 0.35,
        pulseDecay: 1.8
      };

      const glyphs = 'アイウエオカキクケコサシスセソ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%&*';

      function resize(){
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
        w = window.innerWidth; h = window.innerHeight;
        c.width = Math.floor(w*dpr); c.height = Math.floor(h*dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);

        // Font metrics
        fontSize = Math.max(12, Math.floor(w/70));
        glyphSpacing = Math.round(fontSize * RAIN.spacing);
        ctx.font = fontSize + 'px monospace';
        ctx.textBaseline = 'top';

        cols = Math.max(1, Math.ceil(w / glyphSpacing));
        yRows   = Array(cols).fill(0).map(()=> -Math.random()*50);
        velRows = Array(cols).fill(0).map(()=> RAIN.rowsPerSec * (1 + (Math.random()*2-1)*RAIN.variability));
        pulseA  = Array(cols).fill(0);
        rowFrac = Array(cols).fill(0);
        lastRow = Array(cols).fill(-1);
      }
      window.addEventListener('resize', resize, {passive:true});
      resize();

      let lastTs = 0;
      function frame(ts){
        if(!lastTs) lastTs = ts;
        const dt = (ts - lastTs) / 1000; // seconds since last frame
        lastTs = ts;

        if (!document.hidden) {
          // Trail fade
          ctx.fillStyle = `rgba(0,20,0,${RAIN.trail})`;
          ctx.fillRect(0,0,w,h);

          const rainColor = getComputedStyle(document.documentElement).getPropertyValue('--rainColor').trim();

          for (let i=0;i<cols;i++) {
            // accumulate spatial progress in rows (not pixels)
            rowFrac[i] += velRows[i] * dt;

            // Red pulse process: Poisson with rate lambda (per second)
            const pPulse = 1 - Math.exp(-RAIN.pulseLambda * dt);
            if (pulseA[i] <= 0 && Math.random() < pPulse) pulseA[i] = 1; // trigger
            if (pulseA[i] > 0) pulseA[i] = Math.max(0, pulseA[i] - RAIN.pulseDecay * dt);

            // Emit one glyph per WHOLE row advanced
            while (rowFrac[i] >= 1) {
              rowFrac[i] -= 1;
              yRows[i] += 1; // advance exactly one row

              const row = Math.floor(yRows[i]);
              if (row !== lastRow[i]) { // draw only once per row
                const x = i * glyphSpacing;
                const y = row * glyphSpacing;

                // choose color
                if (pulseA[i] > 0) {
                  ctx.fillStyle = `rgba(55,150,60,${pulseA[i].toFixed(3)})`;
                } else {
                  ctx.fillStyle = rainColor;
                }

                const ch = glyphs[Math.floor(Math.random()*glyphs.length)];
                ctx.fillText(ch, x, y);
                lastRow[i] = row;

                // reset when off-screen
                if (y > h && Math.random() > 0.97) {
                  yRows[i] = -Math.random()*20;
                  lastRow[i] = -1;
                  velRows[i] = RAIN.rowsPerSec * (1 + (Math.random()*2-1)*RAIN.variability);
                  rowFrac[i] = 0;
                  break; // move to next column
                }
              } else {
                // already drew this row; if below screen, reset
                if ((row * glyphSpacing) > h) {
                  yRows[i] = -Math.random()*20; lastRow[i] = -1; rowFrac[i] = 0;
                  velRows[i] = RAIN.rowsPerSec * (1 + (Math.random()*2-1)*RAIN.variability);
                  break;
                }
              }
            }
          }
        }
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);

      // Expose knobs for live tuning in console if desired
      window.CIR_RAIN = RAIN;
    })();

    // ===== Title pulse (random timing & brightness) =====
    (()=>{
      const el = document.getElementById('title');
      function pulseOnce(){
        const dur = 180 + Math.random()*220; // 180–400ms
        const amp = 1 + Math.random()*0.02;   // subtle scale
        const bright = 0.9 + Math.random()*0.25; // 0.9–1.15
        el.animate([
          { transform:'scale(1)',      filter:`brightness(${bright})` },
          { transform:`scale(${amp})`,  filter:`brightness(${Math.min(1.25, bright+0.1)})` },
          { transform:'scale(1)',      filter:`brightness(${bright})` }
        ], { duration: dur, easing:'ease-in-out' });
      }
      (function schedule(){
        const wait = 500 + Math.random()*3500;
        setTimeout(()=>{ pulseOnce(); schedule(); }, wait);
      })();
    })();

    // Year stamp
    document.getElementById('y').textContent = new Date().getFullYear();
  </script>
</body>
</html>
